// Constants for secp256k1 curve
// All values stored in little-endian format to match field arithmetic

// Field prime: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
// = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1
// = 2^256 - 2^32 - 977
pub const FIELD_SIZE: [u8; 32] = [
    0x2F, 0xFC, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,  // Low bytes first (little-endian)
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // High bytes last
];

// Curve order (number of points)
// = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141  
pub const CURVE_ORDER: [u8; 32] = [
    0x41, 0x41, 0x36, 0xD0, 0x8C, 0x5E, 0xD2, 0xBF,  // Low bytes first (little-endian)
    0x3B, 0xA0, 0x48, 0xAF, 0xE6, 0xDC, 0xAE, 0xBA,
    0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // High bytes last
];

// Generator point G coordinates
// Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
pub const GENERATOR_X: [u8; 32] = [
    0x98, 0x17, 0xF8, 0x16, 0x5B, 0x81, 0xF2, 0x59,  // Low bytes first (little-endian)
    0xD9, 0x28, 0xCE, 0x2D, 0xDB, 0xFC, 0x9B, 0x02,
    0x07, 0x0B, 0x87, 0xCE, 0x95, 0x62, 0xA0, 0x55,
    0xAC, 0xBB, 0xDC, 0xF9, 0x7E, 0x66, 0xBE, 0x79,  // High bytes last
];

// Gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8
pub const GENERATOR_Y: [u8; 32] = [
    0xB8, 0xD4, 0x10, 0xFB, 0x8F, 0xD0, 0x47, 0x9C,  // Low bytes first (little-endian)
    0x19, 0x54, 0x85, 0xA6, 0x48, 0xB4, 0x17, 0xFD,
    0xA8, 0x08, 0x11, 0x0E, 0xFC, 0xFB, 0xA4, 0x5D,
    0x65, 0xC4, 0xA3, 0x26, 0x77, 0xDA, 0x3A, 0x48,  // High bytes last
];

// Field prime - 2 (for modular inversion using Fermat's little theorem)
// p-2 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2D
pub const FIELD_PRIME_MINUS_2: [u8; 32] = [
    0x2D, 0xFC, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,  // Low bytes first (little-endian)
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // High bytes last
];

// Field prime + 1, divided by 4 (for square root computation using Tonelli-Shanks)
// Since p â‰¡ 3 (mod 4), we can compute sqrt(a) = a^((p+1)/4) mod p
// (p+1)/4 = 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFF0C
pub const FIELD_PRIME_PLUS_1_DIV_4: [u8; 32] = [
    0x0C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // Low bytes first (little-endian)
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F,  // High bytes last
];
